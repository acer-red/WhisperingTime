// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.30.2
// source: whisperingtime.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ThemeService_ListThemes_FullMethodName      = "/whisperingtime.ThemeService/ListThemes"
	ThemeService_CreateTheme_FullMethodName     = "/whisperingtime.ThemeService/CreateTheme"
	ThemeService_UpdateTheme_FullMethodName     = "/whisperingtime.ThemeService/UpdateTheme"
	ThemeService_DeleteTheme_FullMethodName     = "/whisperingtime.ThemeService/DeleteTheme"
	ThemeService_ExportAllConfig_FullMethodName = "/whisperingtime.ThemeService/ExportAllConfig"
)

// ThemeServiceClient is the client API for ThemeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ThemeServiceClient interface {
	ListThemes(ctx context.Context, in *ListThemesRequest, opts ...grpc.CallOption) (*ListThemesResponse, error)
	CreateTheme(ctx context.Context, in *CreateThemeRequest, opts ...grpc.CallOption) (*CreateThemeResponse, error)
	UpdateTheme(ctx context.Context, in *UpdateThemeRequest, opts ...grpc.CallOption) (*BasicResponse, error)
	DeleteTheme(ctx context.Context, in *DeleteThemeRequest, opts ...grpc.CallOption) (*BasicResponse, error)
	ExportAllConfig(ctx context.Context, in *ExportAllConfigRequest, opts ...grpc.CallOption) (*BasicResponse, error)
}

type themeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewThemeServiceClient(cc grpc.ClientConnInterface) ThemeServiceClient {
	return &themeServiceClient{cc}
}

func (c *themeServiceClient) ListThemes(ctx context.Context, in *ListThemesRequest, opts ...grpc.CallOption) (*ListThemesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListThemesResponse)
	err := c.cc.Invoke(ctx, ThemeService_ListThemes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *themeServiceClient) CreateTheme(ctx context.Context, in *CreateThemeRequest, opts ...grpc.CallOption) (*CreateThemeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateThemeResponse)
	err := c.cc.Invoke(ctx, ThemeService_CreateTheme_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *themeServiceClient) UpdateTheme(ctx context.Context, in *UpdateThemeRequest, opts ...grpc.CallOption) (*BasicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BasicResponse)
	err := c.cc.Invoke(ctx, ThemeService_UpdateTheme_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *themeServiceClient) DeleteTheme(ctx context.Context, in *DeleteThemeRequest, opts ...grpc.CallOption) (*BasicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BasicResponse)
	err := c.cc.Invoke(ctx, ThemeService_DeleteTheme_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *themeServiceClient) ExportAllConfig(ctx context.Context, in *ExportAllConfigRequest, opts ...grpc.CallOption) (*BasicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BasicResponse)
	err := c.cc.Invoke(ctx, ThemeService_ExportAllConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ThemeServiceServer is the server API for ThemeService service.
// All implementations must embed UnimplementedThemeServiceServer
// for forward compatibility.
type ThemeServiceServer interface {
	ListThemes(context.Context, *ListThemesRequest) (*ListThemesResponse, error)
	CreateTheme(context.Context, *CreateThemeRequest) (*CreateThemeResponse, error)
	UpdateTheme(context.Context, *UpdateThemeRequest) (*BasicResponse, error)
	DeleteTheme(context.Context, *DeleteThemeRequest) (*BasicResponse, error)
	ExportAllConfig(context.Context, *ExportAllConfigRequest) (*BasicResponse, error)
	mustEmbedUnimplementedThemeServiceServer()
}

// UnimplementedThemeServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedThemeServiceServer struct{}

func (UnimplementedThemeServiceServer) ListThemes(context.Context, *ListThemesRequest) (*ListThemesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListThemes not implemented")
}
func (UnimplementedThemeServiceServer) CreateTheme(context.Context, *CreateThemeRequest) (*CreateThemeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTheme not implemented")
}
func (UnimplementedThemeServiceServer) UpdateTheme(context.Context, *UpdateThemeRequest) (*BasicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTheme not implemented")
}
func (UnimplementedThemeServiceServer) DeleteTheme(context.Context, *DeleteThemeRequest) (*BasicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTheme not implemented")
}
func (UnimplementedThemeServiceServer) ExportAllConfig(context.Context, *ExportAllConfigRequest) (*BasicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportAllConfig not implemented")
}
func (UnimplementedThemeServiceServer) mustEmbedUnimplementedThemeServiceServer() {}
func (UnimplementedThemeServiceServer) testEmbeddedByValue()                      {}

// UnsafeThemeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ThemeServiceServer will
// result in compilation errors.
type UnsafeThemeServiceServer interface {
	mustEmbedUnimplementedThemeServiceServer()
}

func RegisterThemeServiceServer(s grpc.ServiceRegistrar, srv ThemeServiceServer) {
	// If the following call pancis, it indicates UnimplementedThemeServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ThemeService_ServiceDesc, srv)
}

func _ThemeService_ListThemes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListThemesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ThemeServiceServer).ListThemes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ThemeService_ListThemes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ThemeServiceServer).ListThemes(ctx, req.(*ListThemesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ThemeService_CreateTheme_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateThemeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ThemeServiceServer).CreateTheme(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ThemeService_CreateTheme_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ThemeServiceServer).CreateTheme(ctx, req.(*CreateThemeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ThemeService_UpdateTheme_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateThemeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ThemeServiceServer).UpdateTheme(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ThemeService_UpdateTheme_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ThemeServiceServer).UpdateTheme(ctx, req.(*UpdateThemeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ThemeService_DeleteTheme_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteThemeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ThemeServiceServer).DeleteTheme(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ThemeService_DeleteTheme_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ThemeServiceServer).DeleteTheme(ctx, req.(*DeleteThemeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ThemeService_ExportAllConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportAllConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ThemeServiceServer).ExportAllConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ThemeService_ExportAllConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ThemeServiceServer).ExportAllConfig(ctx, req.(*ExportAllConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ThemeService_ServiceDesc is the grpc.ServiceDesc for ThemeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ThemeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "whisperingtime.ThemeService",
	HandlerType: (*ThemeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListThemes",
			Handler:    _ThemeService_ListThemes_Handler,
		},
		{
			MethodName: "CreateTheme",
			Handler:    _ThemeService_CreateTheme_Handler,
		},
		{
			MethodName: "UpdateTheme",
			Handler:    _ThemeService_UpdateTheme_Handler,
		},
		{
			MethodName: "DeleteTheme",
			Handler:    _ThemeService_DeleteTheme_Handler,
		},
		{
			MethodName: "ExportAllConfig",
			Handler:    _ThemeService_ExportAllConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "whisperingtime.proto",
}

const (
	GroupService_ListGroups_FullMethodName        = "/whisperingtime.GroupService/ListGroups"
	GroupService_GetGroup_FullMethodName          = "/whisperingtime.GroupService/GetGroup"
	GroupService_CreateGroup_FullMethodName       = "/whisperingtime.GroupService/CreateGroup"
	GroupService_UpdateGroup_FullMethodName       = "/whisperingtime.GroupService/UpdateGroup"
	GroupService_DeleteGroup_FullMethodName       = "/whisperingtime.GroupService/DeleteGroup"
	GroupService_ExportGroupConfig_FullMethodName = "/whisperingtime.GroupService/ExportGroupConfig"
	GroupService_ImportGroupConfig_FullMethodName = "/whisperingtime.GroupService/ImportGroupConfig"
)

// GroupServiceClient is the client API for GroupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GroupServiceClient interface {
	ListGroups(ctx context.Context, in *ListGroupsRequest, opts ...grpc.CallOption) (*ListGroupsResponse, error)
	GetGroup(ctx context.Context, in *GetGroupRequest, opts ...grpc.CallOption) (*GetGroupResponse, error)
	CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error)
	UpdateGroup(ctx context.Context, in *UpdateGroupRequest, opts ...grpc.CallOption) (*BasicResponse, error)
	DeleteGroup(ctx context.Context, in *DeleteGroupRequest, opts ...grpc.CallOption) (*BasicResponse, error)
	ExportGroupConfig(ctx context.Context, in *ExportGroupConfigRequest, opts ...grpc.CallOption) (*BasicResponse, error)
	// Client streaming upload of config zip
	ImportGroupConfig(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[BytesChunk, ImportGroupConfigResponse], error)
}

type groupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGroupServiceClient(cc grpc.ClientConnInterface) GroupServiceClient {
	return &groupServiceClient{cc}
}

func (c *groupServiceClient) ListGroups(ctx context.Context, in *ListGroupsRequest, opts ...grpc.CallOption) (*ListGroupsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListGroupsResponse)
	err := c.cc.Invoke(ctx, GroupService_ListGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) GetGroup(ctx context.Context, in *GetGroupRequest, opts ...grpc.CallOption) (*GetGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetGroupResponse)
	err := c.cc.Invoke(ctx, GroupService_GetGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateGroupResponse)
	err := c.cc.Invoke(ctx, GroupService_CreateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) UpdateGroup(ctx context.Context, in *UpdateGroupRequest, opts ...grpc.CallOption) (*BasicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BasicResponse)
	err := c.cc.Invoke(ctx, GroupService_UpdateGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) DeleteGroup(ctx context.Context, in *DeleteGroupRequest, opts ...grpc.CallOption) (*BasicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BasicResponse)
	err := c.cc.Invoke(ctx, GroupService_DeleteGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) ExportGroupConfig(ctx context.Context, in *ExportGroupConfigRequest, opts ...grpc.CallOption) (*BasicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BasicResponse)
	err := c.cc.Invoke(ctx, GroupService_ExportGroupConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) ImportGroupConfig(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[BytesChunk, ImportGroupConfigResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &GroupService_ServiceDesc.Streams[0], GroupService_ImportGroupConfig_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[BytesChunk, ImportGroupConfigResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GroupService_ImportGroupConfigClient = grpc.ClientStreamingClient[BytesChunk, ImportGroupConfigResponse]

// GroupServiceServer is the server API for GroupService service.
// All implementations must embed UnimplementedGroupServiceServer
// for forward compatibility.
type GroupServiceServer interface {
	ListGroups(context.Context, *ListGroupsRequest) (*ListGroupsResponse, error)
	GetGroup(context.Context, *GetGroupRequest) (*GetGroupResponse, error)
	CreateGroup(context.Context, *CreateGroupRequest) (*CreateGroupResponse, error)
	UpdateGroup(context.Context, *UpdateGroupRequest) (*BasicResponse, error)
	DeleteGroup(context.Context, *DeleteGroupRequest) (*BasicResponse, error)
	ExportGroupConfig(context.Context, *ExportGroupConfigRequest) (*BasicResponse, error)
	// Client streaming upload of config zip
	ImportGroupConfig(grpc.ClientStreamingServer[BytesChunk, ImportGroupConfigResponse]) error
	mustEmbedUnimplementedGroupServiceServer()
}

// UnimplementedGroupServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGroupServiceServer struct{}

func (UnimplementedGroupServiceServer) ListGroups(context.Context, *ListGroupsRequest) (*ListGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListGroups not implemented")
}
func (UnimplementedGroupServiceServer) GetGroup(context.Context, *GetGroupRequest) (*GetGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroup not implemented")
}
func (UnimplementedGroupServiceServer) CreateGroup(context.Context, *CreateGroupRequest) (*CreateGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGroup not implemented")
}
func (UnimplementedGroupServiceServer) UpdateGroup(context.Context, *UpdateGroupRequest) (*BasicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroup not implemented")
}
func (UnimplementedGroupServiceServer) DeleteGroup(context.Context, *DeleteGroupRequest) (*BasicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGroup not implemented")
}
func (UnimplementedGroupServiceServer) ExportGroupConfig(context.Context, *ExportGroupConfigRequest) (*BasicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExportGroupConfig not implemented")
}
func (UnimplementedGroupServiceServer) ImportGroupConfig(grpc.ClientStreamingServer[BytesChunk, ImportGroupConfigResponse]) error {
	return status.Errorf(codes.Unimplemented, "method ImportGroupConfig not implemented")
}
func (UnimplementedGroupServiceServer) mustEmbedUnimplementedGroupServiceServer() {}
func (UnimplementedGroupServiceServer) testEmbeddedByValue()                      {}

// UnsafeGroupServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GroupServiceServer will
// result in compilation errors.
type UnsafeGroupServiceServer interface {
	mustEmbedUnimplementedGroupServiceServer()
}

func RegisterGroupServiceServer(s grpc.ServiceRegistrar, srv GroupServiceServer) {
	// If the following call pancis, it indicates UnimplementedGroupServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&GroupService_ServiceDesc, srv)
}

func _GroupService_ListGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).ListGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupService_ListGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).ListGroups(ctx, req.(*ListGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_GetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).GetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupService_GetGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).GetGroup(ctx, req.(*GetGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupService_CreateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).CreateGroup(ctx, req.(*CreateGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_UpdateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).UpdateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupService_UpdateGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).UpdateGroup(ctx, req.(*UpdateGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupService_DeleteGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).DeleteGroup(ctx, req.(*DeleteGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_ExportGroupConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExportGroupConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).ExportGroupConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GroupService_ExportGroupConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).ExportGroupConfig(ctx, req.(*ExportGroupConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_ImportGroupConfig_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GroupServiceServer).ImportGroupConfig(&grpc.GenericServerStream[BytesChunk, ImportGroupConfigResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type GroupService_ImportGroupConfigServer = grpc.ClientStreamingServer[BytesChunk, ImportGroupConfigResponse]

// GroupService_ServiceDesc is the grpc.ServiceDesc for GroupService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GroupService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "whisperingtime.GroupService",
	HandlerType: (*GroupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListGroups",
			Handler:    _GroupService_ListGroups_Handler,
		},
		{
			MethodName: "GetGroup",
			Handler:    _GroupService_GetGroup_Handler,
		},
		{
			MethodName: "CreateGroup",
			Handler:    _GroupService_CreateGroup_Handler,
		},
		{
			MethodName: "UpdateGroup",
			Handler:    _GroupService_UpdateGroup_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _GroupService_DeleteGroup_Handler,
		},
		{
			MethodName: "ExportGroupConfig",
			Handler:    _GroupService_ExportGroupConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ImportGroupConfig",
			Handler:       _GroupService_ImportGroupConfig_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "whisperingtime.proto",
}

const (
	DocService_ListDocs_FullMethodName  = "/whisperingtime.DocService/ListDocs"
	DocService_CreateDoc_FullMethodName = "/whisperingtime.DocService/CreateDoc"
	DocService_UpdateDoc_FullMethodName = "/whisperingtime.DocService/UpdateDoc"
	DocService_DeleteDoc_FullMethodName = "/whisperingtime.DocService/DeleteDoc"
)

// DocServiceClient is the client API for DocService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DocServiceClient interface {
	ListDocs(ctx context.Context, in *ListDocsRequest, opts ...grpc.CallOption) (*ListDocsResponse, error)
	CreateDoc(ctx context.Context, in *CreateDocRequest, opts ...grpc.CallOption) (*CreateDocResponse, error)
	UpdateDoc(ctx context.Context, in *UpdateDocRequest, opts ...grpc.CallOption) (*BasicResponse, error)
	DeleteDoc(ctx context.Context, in *DeleteDocRequest, opts ...grpc.CallOption) (*BasicResponse, error)
}

type docServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDocServiceClient(cc grpc.ClientConnInterface) DocServiceClient {
	return &docServiceClient{cc}
}

func (c *docServiceClient) ListDocs(ctx context.Context, in *ListDocsRequest, opts ...grpc.CallOption) (*ListDocsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListDocsResponse)
	err := c.cc.Invoke(ctx, DocService_ListDocs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docServiceClient) CreateDoc(ctx context.Context, in *CreateDocRequest, opts ...grpc.CallOption) (*CreateDocResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateDocResponse)
	err := c.cc.Invoke(ctx, DocService_CreateDoc_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docServiceClient) UpdateDoc(ctx context.Context, in *UpdateDocRequest, opts ...grpc.CallOption) (*BasicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BasicResponse)
	err := c.cc.Invoke(ctx, DocService_UpdateDoc_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *docServiceClient) DeleteDoc(ctx context.Context, in *DeleteDocRequest, opts ...grpc.CallOption) (*BasicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BasicResponse)
	err := c.cc.Invoke(ctx, DocService_DeleteDoc_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DocServiceServer is the server API for DocService service.
// All implementations must embed UnimplementedDocServiceServer
// for forward compatibility.
type DocServiceServer interface {
	ListDocs(context.Context, *ListDocsRequest) (*ListDocsResponse, error)
	CreateDoc(context.Context, *CreateDocRequest) (*CreateDocResponse, error)
	UpdateDoc(context.Context, *UpdateDocRequest) (*BasicResponse, error)
	DeleteDoc(context.Context, *DeleteDocRequest) (*BasicResponse, error)
	mustEmbedUnimplementedDocServiceServer()
}

// UnimplementedDocServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDocServiceServer struct{}

func (UnimplementedDocServiceServer) ListDocs(context.Context, *ListDocsRequest) (*ListDocsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDocs not implemented")
}
func (UnimplementedDocServiceServer) CreateDoc(context.Context, *CreateDocRequest) (*CreateDocResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDoc not implemented")
}
func (UnimplementedDocServiceServer) UpdateDoc(context.Context, *UpdateDocRequest) (*BasicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDoc not implemented")
}
func (UnimplementedDocServiceServer) DeleteDoc(context.Context, *DeleteDocRequest) (*BasicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDoc not implemented")
}
func (UnimplementedDocServiceServer) mustEmbedUnimplementedDocServiceServer() {}
func (UnimplementedDocServiceServer) testEmbeddedByValue()                    {}

// UnsafeDocServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DocServiceServer will
// result in compilation errors.
type UnsafeDocServiceServer interface {
	mustEmbedUnimplementedDocServiceServer()
}

func RegisterDocServiceServer(s grpc.ServiceRegistrar, srv DocServiceServer) {
	// If the following call pancis, it indicates UnimplementedDocServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DocService_ServiceDesc, srv)
}

func _DocService_ListDocs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDocsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocServiceServer).ListDocs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocService_ListDocs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocServiceServer).ListDocs(ctx, req.(*ListDocsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocService_CreateDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocServiceServer).CreateDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocService_CreateDoc_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocServiceServer).CreateDoc(ctx, req.(*CreateDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocService_UpdateDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocServiceServer).UpdateDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocService_UpdateDoc_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocServiceServer).UpdateDoc(ctx, req.(*UpdateDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DocService_DeleteDoc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDocRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DocServiceServer).DeleteDoc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DocService_DeleteDoc_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DocServiceServer).DeleteDoc(ctx, req.(*DeleteDocRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DocService_ServiceDesc is the grpc.ServiceDesc for DocService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DocService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "whisperingtime.DocService",
	HandlerType: (*DocServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListDocs",
			Handler:    _DocService_ListDocs_Handler,
		},
		{
			MethodName: "CreateDoc",
			Handler:    _DocService_CreateDoc_Handler,
		},
		{
			MethodName: "UpdateDoc",
			Handler:    _DocService_UpdateDoc_Handler,
		},
		{
			MethodName: "DeleteDoc",
			Handler:    _DocService_DeleteDoc_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "whisperingtime.proto",
}

const (
	ImageService_UploadImage_FullMethodName = "/whisperingtime.ImageService/UploadImage"
	ImageService_DeleteImage_FullMethodName = "/whisperingtime.ImageService/DeleteImage"
)

// ImageServiceClient is the client API for ImageService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ImageServiceClient interface {
	// Client streaming upload: send BytesChunk with metadata in first chunk header
	UploadImage(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ImageUploadChunk, UploadImageResponse], error)
	DeleteImage(ctx context.Context, in *DeleteImageRequest, opts ...grpc.CallOption) (*BasicResponse, error)
}

type imageServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewImageServiceClient(cc grpc.ClientConnInterface) ImageServiceClient {
	return &imageServiceClient{cc}
}

func (c *imageServiceClient) UploadImage(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[ImageUploadChunk, UploadImageResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ImageService_ServiceDesc.Streams[0], ImageService_UploadImage_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ImageUploadChunk, UploadImageResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ImageService_UploadImageClient = grpc.ClientStreamingClient[ImageUploadChunk, UploadImageResponse]

func (c *imageServiceClient) DeleteImage(ctx context.Context, in *DeleteImageRequest, opts ...grpc.CallOption) (*BasicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BasicResponse)
	err := c.cc.Invoke(ctx, ImageService_DeleteImage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImageServiceServer is the server API for ImageService service.
// All implementations must embed UnimplementedImageServiceServer
// for forward compatibility.
type ImageServiceServer interface {
	// Client streaming upload: send BytesChunk with metadata in first chunk header
	UploadImage(grpc.ClientStreamingServer[ImageUploadChunk, UploadImageResponse]) error
	DeleteImage(context.Context, *DeleteImageRequest) (*BasicResponse, error)
	mustEmbedUnimplementedImageServiceServer()
}

// UnimplementedImageServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedImageServiceServer struct{}

func (UnimplementedImageServiceServer) UploadImage(grpc.ClientStreamingServer[ImageUploadChunk, UploadImageResponse]) error {
	return status.Errorf(codes.Unimplemented, "method UploadImage not implemented")
}
func (UnimplementedImageServiceServer) DeleteImage(context.Context, *DeleteImageRequest) (*BasicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteImage not implemented")
}
func (UnimplementedImageServiceServer) mustEmbedUnimplementedImageServiceServer() {}
func (UnimplementedImageServiceServer) testEmbeddedByValue()                      {}

// UnsafeImageServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImageServiceServer will
// result in compilation errors.
type UnsafeImageServiceServer interface {
	mustEmbedUnimplementedImageServiceServer()
}

func RegisterImageServiceServer(s grpc.ServiceRegistrar, srv ImageServiceServer) {
	// If the following call pancis, it indicates UnimplementedImageServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ImageService_ServiceDesc, srv)
}

func _ImageService_UploadImage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ImageServiceServer).UploadImage(&grpc.GenericServerStream[ImageUploadChunk, UploadImageResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ImageService_UploadImageServer = grpc.ClientStreamingServer[ImageUploadChunk, UploadImageResponse]

func _ImageService_DeleteImage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageServiceServer).DeleteImage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageService_DeleteImage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageServiceServer).DeleteImage(ctx, req.(*DeleteImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ImageService_ServiceDesc is the grpc.ServiceDesc for ImageService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ImageService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "whisperingtime.ImageService",
	HandlerType: (*ImageServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DeleteImage",
			Handler:    _ImageService_DeleteImage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadImage",
			Handler:       _ImageService_UploadImage_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "whisperingtime.proto",
}

const (
	BackgroundJobService_ListJobs_FullMethodName        = "/whisperingtime.BackgroundJobService/ListJobs"
	BackgroundJobService_GetJob_FullMethodName          = "/whisperingtime.BackgroundJobService/GetJob"
	BackgroundJobService_DeleteJob_FullMethodName       = "/whisperingtime.BackgroundJobService/DeleteJob"
	BackgroundJobService_DownloadJobFile_FullMethodName = "/whisperingtime.BackgroundJobService/DownloadJobFile"
)

// BackgroundJobServiceClient is the client API for BackgroundJobService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BackgroundJobServiceClient interface {
	ListJobs(ctx context.Context, in *ListBackgroundJobsRequest, opts ...grpc.CallOption) (*ListBackgroundJobsResponse, error)
	GetJob(ctx context.Context, in *GetBackgroundJobRequest, opts ...grpc.CallOption) (*BackgroundJob, error)
	DeleteJob(ctx context.Context, in *DeleteBackgroundJobRequest, opts ...grpc.CallOption) (*BasicResponse, error)
	// Per requirement: return bytes (not streaming) for job download
	DownloadJobFile(ctx context.Context, in *DownloadBackgroundJobFileRequest, opts ...grpc.CallOption) (*DownloadBackgroundJobFileResponse, error)
}

type backgroundJobServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewBackgroundJobServiceClient(cc grpc.ClientConnInterface) BackgroundJobServiceClient {
	return &backgroundJobServiceClient{cc}
}

func (c *backgroundJobServiceClient) ListJobs(ctx context.Context, in *ListBackgroundJobsRequest, opts ...grpc.CallOption) (*ListBackgroundJobsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListBackgroundJobsResponse)
	err := c.cc.Invoke(ctx, BackgroundJobService_ListJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundJobServiceClient) GetJob(ctx context.Context, in *GetBackgroundJobRequest, opts ...grpc.CallOption) (*BackgroundJob, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BackgroundJob)
	err := c.cc.Invoke(ctx, BackgroundJobService_GetJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundJobServiceClient) DeleteJob(ctx context.Context, in *DeleteBackgroundJobRequest, opts ...grpc.CallOption) (*BasicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BasicResponse)
	err := c.cc.Invoke(ctx, BackgroundJobService_DeleteJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backgroundJobServiceClient) DownloadJobFile(ctx context.Context, in *DownloadBackgroundJobFileRequest, opts ...grpc.CallOption) (*DownloadBackgroundJobFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DownloadBackgroundJobFileResponse)
	err := c.cc.Invoke(ctx, BackgroundJobService_DownloadJobFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackgroundJobServiceServer is the server API for BackgroundJobService service.
// All implementations must embed UnimplementedBackgroundJobServiceServer
// for forward compatibility.
type BackgroundJobServiceServer interface {
	ListJobs(context.Context, *ListBackgroundJobsRequest) (*ListBackgroundJobsResponse, error)
	GetJob(context.Context, *GetBackgroundJobRequest) (*BackgroundJob, error)
	DeleteJob(context.Context, *DeleteBackgroundJobRequest) (*BasicResponse, error)
	// Per requirement: return bytes (not streaming) for job download
	DownloadJobFile(context.Context, *DownloadBackgroundJobFileRequest) (*DownloadBackgroundJobFileResponse, error)
	mustEmbedUnimplementedBackgroundJobServiceServer()
}

// UnimplementedBackgroundJobServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedBackgroundJobServiceServer struct{}

func (UnimplementedBackgroundJobServiceServer) ListJobs(context.Context, *ListBackgroundJobsRequest) (*ListBackgroundJobsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListJobs not implemented")
}
func (UnimplementedBackgroundJobServiceServer) GetJob(context.Context, *GetBackgroundJobRequest) (*BackgroundJob, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetJob not implemented")
}
func (UnimplementedBackgroundJobServiceServer) DeleteJob(context.Context, *DeleteBackgroundJobRequest) (*BasicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJob not implemented")
}
func (UnimplementedBackgroundJobServiceServer) DownloadJobFile(context.Context, *DownloadBackgroundJobFileRequest) (*DownloadBackgroundJobFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DownloadJobFile not implemented")
}
func (UnimplementedBackgroundJobServiceServer) mustEmbedUnimplementedBackgroundJobServiceServer() {}
func (UnimplementedBackgroundJobServiceServer) testEmbeddedByValue()                              {}

// UnsafeBackgroundJobServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BackgroundJobServiceServer will
// result in compilation errors.
type UnsafeBackgroundJobServiceServer interface {
	mustEmbedUnimplementedBackgroundJobServiceServer()
}

func RegisterBackgroundJobServiceServer(s grpc.ServiceRegistrar, srv BackgroundJobServiceServer) {
	// If the following call pancis, it indicates UnimplementedBackgroundJobServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&BackgroundJobService_ServiceDesc, srv)
}

func _BackgroundJobService_ListJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackgroundJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundJobServiceServer).ListJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundJobService_ListJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundJobServiceServer).ListJobs(ctx, req.(*ListBackgroundJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundJobService_GetJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackgroundJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundJobServiceServer).GetJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundJobService_GetJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundJobServiceServer).GetJob(ctx, req.(*GetBackgroundJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundJobService_DeleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBackgroundJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundJobServiceServer).DeleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundJobService_DeleteJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundJobServiceServer).DeleteJob(ctx, req.(*DeleteBackgroundJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackgroundJobService_DownloadJobFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DownloadBackgroundJobFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackgroundJobServiceServer).DownloadJobFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackgroundJobService_DownloadJobFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackgroundJobServiceServer).DownloadJobFile(ctx, req.(*DownloadBackgroundJobFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BackgroundJobService_ServiceDesc is the grpc.ServiceDesc for BackgroundJobService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BackgroundJobService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "whisperingtime.BackgroundJobService",
	HandlerType: (*BackgroundJobServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListJobs",
			Handler:    _BackgroundJobService_ListJobs_Handler,
		},
		{
			MethodName: "GetJob",
			Handler:    _BackgroundJobService_GetJob_Handler,
		},
		{
			MethodName: "DeleteJob",
			Handler:    _BackgroundJobService_DeleteJob_Handler,
		},
		{
			MethodName: "DownloadJobFile",
			Handler:    _BackgroundJobService_DownloadJobFile_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "whisperingtime.proto",
}

const (
	FileService_PresignUploadFile_FullMethodName   = "/whisperingtime.FileService/PresignUploadFile"
	FileService_PresignDownloadFile_FullMethodName = "/whisperingtime.FileService/PresignDownloadFile"
	FileService_DeleteFile_FullMethodName          = "/whisperingtime.FileService/DeleteFile"
)

// FileServiceClient is the client API for FileService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FileServiceClient interface {
	PresignUploadFile(ctx context.Context, in *PresignUploadFileRequest, opts ...grpc.CallOption) (*PresignUploadFileResponse, error)
	PresignDownloadFile(ctx context.Context, in *PresignDownloadFileRequest, opts ...grpc.CallOption) (*PresignDownloadFileResponse, error)
	DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*BasicResponse, error)
}

type fileServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFileServiceClient(cc grpc.ClientConnInterface) FileServiceClient {
	return &fileServiceClient{cc}
}

func (c *fileServiceClient) PresignUploadFile(ctx context.Context, in *PresignUploadFileRequest, opts ...grpc.CallOption) (*PresignUploadFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PresignUploadFileResponse)
	err := c.cc.Invoke(ctx, FileService_PresignUploadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) PresignDownloadFile(ctx context.Context, in *PresignDownloadFileRequest, opts ...grpc.CallOption) (*PresignDownloadFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PresignDownloadFileResponse)
	err := c.cc.Invoke(ctx, FileService_PresignDownloadFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *fileServiceClient) DeleteFile(ctx context.Context, in *DeleteFileRequest, opts ...grpc.CallOption) (*BasicResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BasicResponse)
	err := c.cc.Invoke(ctx, FileService_DeleteFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FileServiceServer is the server API for FileService service.
// All implementations must embed UnimplementedFileServiceServer
// for forward compatibility.
type FileServiceServer interface {
	PresignUploadFile(context.Context, *PresignUploadFileRequest) (*PresignUploadFileResponse, error)
	PresignDownloadFile(context.Context, *PresignDownloadFileRequest) (*PresignDownloadFileResponse, error)
	DeleteFile(context.Context, *DeleteFileRequest) (*BasicResponse, error)
	mustEmbedUnimplementedFileServiceServer()
}

// UnimplementedFileServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedFileServiceServer struct{}

func (UnimplementedFileServiceServer) PresignUploadFile(context.Context, *PresignUploadFileRequest) (*PresignUploadFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PresignUploadFile not implemented")
}
func (UnimplementedFileServiceServer) PresignDownloadFile(context.Context, *PresignDownloadFileRequest) (*PresignDownloadFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PresignDownloadFile not implemented")
}
func (UnimplementedFileServiceServer) DeleteFile(context.Context, *DeleteFileRequest) (*BasicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFile not implemented")
}
func (UnimplementedFileServiceServer) mustEmbedUnimplementedFileServiceServer() {}
func (UnimplementedFileServiceServer) testEmbeddedByValue()                     {}

// UnsafeFileServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FileServiceServer will
// result in compilation errors.
type UnsafeFileServiceServer interface {
	mustEmbedUnimplementedFileServiceServer()
}

func RegisterFileServiceServer(s grpc.ServiceRegistrar, srv FileServiceServer) {
	// If the following call pancis, it indicates UnimplementedFileServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&FileService_ServiceDesc, srv)
}

func _FileService_PresignUploadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PresignUploadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).PresignUploadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_PresignUploadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).PresignUploadFile(ctx, req.(*PresignUploadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_PresignDownloadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PresignDownloadFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).PresignDownloadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_PresignDownloadFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).PresignDownloadFile(ctx, req.(*PresignDownloadFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FileService_DeleteFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FileServiceServer).DeleteFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FileService_DeleteFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FileServiceServer).DeleteFile(ctx, req.(*DeleteFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FileService_ServiceDesc is the grpc.ServiceDesc for FileService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FileService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "whisperingtime.FileService",
	HandlerType: (*FileServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PresignUploadFile",
			Handler:    _FileService_PresignUploadFile_Handler,
		},
		{
			MethodName: "PresignDownloadFile",
			Handler:    _FileService_PresignDownloadFile_Handler,
		},
		{
			MethodName: "DeleteFile",
			Handler:    _FileService_DeleteFile_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "whisperingtime.proto",
}
